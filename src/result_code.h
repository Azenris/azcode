
#pragma once

enum RESULT_CODE
{
	RESULT_CODE_SUCCESS,
	RESULT_CODE_NO_FILE_INPUT_TO_PROCESS,
	RESULT_CODE_FAILED_TO_OPEN_INPUT_FILE,
	RESULT_CODE_FAILED_TO_OPEN_INCLUDED_FILE,
	RESULT_CODE_CANNOT_CONVERT_TO_INT,
	RESULT_CODE_STRING_LITERAL_NOT_CLOSED,
	RESULT_CODE_UNEXPECTED_VALUE,
	RESULT_CODE_UNHANDLED_TOKEN_PARSING,
	RESULT_CODE_UNEXPECTED_TOKEN,
	RESULT_CODE_UNEXPECTED_RESULT_CODE,
	RESULT_CODE_EMPTY_SCRIPT,
	RESULT_CODE_VARIABLE_UNKNOWN,
	RESULT_CODE_FUNCTION_ARG_COUNT,
	RESULT_CODE_PRINT_FORMAT_UNEXPECTED,
	RESULT_CODE_PRINT_FORMAT_TOKEN_ID_UNEXPECTED,
	RESULT_CODE_VALUE_CANNOT_CONVERT,
	RESULT_CODE_VALUE_SUBSCRIPT_OF_NON_ARRAY,
	RESULT_CODE_VALUE_SUBSCRIPT_OUT_OF_RANGE,
	RESULT_CODE_VALUE_NOT_A_FILE,
	RESULT_CODE_VALUE_HAS_NO_COUNT,
	RESULT_CODE_VALUE_UNDEFINED_ARITHMETIC,
	RESULT_CODE_VALUE_UNDEFINED_COMPARITOR,
	RESULT_CODE_VALUE_UNDEFINED_TYPE,
	RESULT_CODE_UNEXPECTED_STRUCT_ASSIGNMENT_TYPE,
	RESULT_CODE_NOT_CALLABLE,
	RESULT_CODE_INVALID_IMPORT,
	RESULT_CODE_INVALID_ARGS_BUILTIN_FUNC,
	RESULT_CODE_ASSERT_FAILED,
};

// --------------------------------------------------------------------

template <>
struct std::formatter<RESULT_CODE>
{
	constexpr auto parse( std::format_parse_context &ctx )
	{
		return ctx.begin();
	}

	std::format_context::iterator format( const RESULT_CODE &code, std::format_context &ctx ) const
	{
		const char *name = "Unknown RESULT_CODE";

		switch ( code )
		{
		case RESULT_CODE_SUCCESS: name = "RESULT_CODE_SUCCESS"; break;
		case RESULT_CODE_NO_FILE_INPUT_TO_PROCESS: name = "RESULT_CODE_NO_FILE_INPUT_TO_PROCESS"; break;
		case RESULT_CODE_FAILED_TO_OPEN_INPUT_FILE: name = "RESULT_CODE_FAILED_TO_OPEN_INPUT_FILE"; break;
		case RESULT_CODE_FAILED_TO_OPEN_INCLUDED_FILE: name = "RESULT_CODE_FAILED_TO_OPEN_INCLUDED_FILE"; break;
		case RESULT_CODE_CANNOT_CONVERT_TO_INT: name = "RESULT_CODE_CANNOT_CONVERT_TO_INT"; break;
		case RESULT_CODE_STRING_LITERAL_NOT_CLOSED: name = "RESULT_CODE_STRING_LITERAL_NOT_CLOSED"; break;
		case RESULT_CODE_UNEXPECTED_VALUE: name = "RESULT_CODE_UNEXPECTED_VALUE"; break;
		case RESULT_CODE_UNHANDLED_TOKEN_PARSING: name = "RESULT_CODE_UNHANDLED_TOKEN_PARSING"; break;
		case RESULT_CODE_UNEXPECTED_TOKEN: name = "RESULT_CODE_UNEXPECTED_TOKEN"; break;
		case RESULT_CODE_UNEXPECTED_RESULT_CODE: name = "RESULT_CODE_UNEXPECTED_RESULT_CODE"; break;
		case RESULT_CODE_EMPTY_SCRIPT: name = "RESULT_CODE_EMPTY_SCRIPT"; break;
		case RESULT_CODE_VARIABLE_UNKNOWN: name = "RESULT_CODE_VARIABLE_UNKNOWN"; break;
		case RESULT_CODE_FUNCTION_ARG_COUNT: name = "RESULT_CODE_FUNCTION_ARG_COUNT"; break;
		case RESULT_CODE_PRINT_FORMAT_UNEXPECTED: name = "RESULT_CODE_PRINT_FORMAT_UNEXPECTED"; break;
		case RESULT_CODE_PRINT_FORMAT_TOKEN_ID_UNEXPECTED: name = "RESULT_CODE_PRINT_FORMAT_TOKEN_ID_UNEXPECTED"; break;
		case RESULT_CODE_VALUE_CANNOT_CONVERT: name = "RESULT_CODE_VALUE_CANNOT_CONVERT"; break;
		case RESULT_CODE_VALUE_SUBSCRIPT_OF_NON_ARRAY: name = "RESULT_CODE_VALUE_SUBSCRIPT_OF_NON_ARRAY"; break;
		case RESULT_CODE_VALUE_SUBSCRIPT_OUT_OF_RANGE: name = "RESULT_CODE_VALUE_SUBSCRIPT_OUT_OF_RANGE"; break;
		case RESULT_CODE_VALUE_HAS_NO_COUNT: name = "RESULT_CODE_VALUE_HAS_NO_COUNT"; break;
		case RESULT_CODE_VALUE_UNDEFINED_ARITHMETIC: name = "RESULT_CODE_VALUE_UNDEFINED_ARITHMETIC"; break;
		case RESULT_CODE_VALUE_UNDEFINED_COMPARITOR: name = "RESULT_CODE_VALUE_UNDEFINED_COMPARITOR"; break;
		case RESULT_CODE_VALUE_UNDEFINED_TYPE: name = "RESULT_CODE_VALUE_UNDEFINED_TYPE"; break;
		case RESULT_CODE_UNEXPECTED_STRUCT_ASSIGNMENT_TYPE: name = "RESULT_CODE_UNEXPECTED_STRUCT_ASSIGNMENT_TYPE"; break;
		case RESULT_CODE_NOT_CALLABLE: name = "RESULT_CODE_NOT_CALLABLE"; break;
		case RESULT_CODE_INVALID_IMPORT: name = "RESULT_CODE_INVALID_IMPORT"; break;
		case RESULT_CODE_INVALID_ARGS_BUILTIN_FUNC: name = "RESULT_CODE_INVALID_ARGS_BUILTIN_FUNC"; break;
		case RESULT_CODE_ASSERT_FAILED: name = "RESULT_CODE_ASSERT_FAILED"; break;
		}

		return std::format_to( ctx.out(), "{}", name );
	}
};